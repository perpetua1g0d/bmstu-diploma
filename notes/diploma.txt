Текущие вопросы:
- должно ли на CD быть makefile/installer с установкой всех зависимостей (k8s, ...)?
- в чем главное отличие диплома от курсача в контексте ПАК? в дипломе какая-то из технологий должна отсутствовать и быть написана с нуля? объем?
- существующие подходы - например, на хабре есть статьи как устроено подобное решение в другой компании. На это можно ссылаться как-либо в дипломе?
- засунуть куда-то в требования high-load (опасно, нужно продумать)
- как формализовать постановку задачи, что система планируется использоваться в high-load системах с большим количеством микросервисов (overkill для использования в маленьких системах)?
- предполагаем, что у обычных (бизнес, неинфраструктурных) микросервисов уже работает авторизация? нужно ли ее реализовывать в дипломе? диплом чисто про авторизацию обычных в инфраструктруные микросервисы
	- НУЖНО ПОМНИТЬ ЧТО В ДИПЛОМЕ I2I, НЕ S2I. Возможно, и не придется поднимать бизнес-микросервисы
- должно ли мое решение быть plug&play? могу ли я ограничиться стеком в Озоне или это должно быть решение, применимое к любой архитектуре?

Обосновать выбор k8s (highload, отказоустойчивость), а не докер. Паттерн sidecar
- Кубовые токены вместо волта?
- мини-талос вместо keycloak? но для u2i удобнее keycloak видимо

Про service account, RBAC https://habr.com/ru/articles/779190/
k8s дока: https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/

В каждом кластере есть корневой CA (Certificate Authority), который используется для подписи различных сертификатов, включая сертификаты API-сервера. Когда под создается, он автоматически монтирует секрет service account, который включает токен и CA сертификат. Этот CA сертификат — это публичная часть корневого CA кластера.

Вопросы, которые могут возникнуть к работе:
- Различие между сервисами и инфрой - подготовиться к объяснению инфры (постгря, кафка, талос, ...)
- Зачем кубер?
- Зачем потребовалось разделять s2s и s2i, почему нельзя сделать общей авторизацию в микросервисах?
	- Если можно засунуть и s2s в сайдкар (авито), то тогда зачем этот гемор с разделением на инфру/не инфру
- Если работа по i2i, то где s2i? Если s2i, то где i2i? - от этого защититься в РПЗ
- Зачем эту систему понадобилось сооружать, точно проще нельзя сделать? - можно ответить, что 1) ИБ, 2) не очень в 		конфигах поддерживать [про это должно быть в РПЗ очевидно], 3) не дать просто так разрабам власть над доступами
	(zero trust)
- Могут проводить аналогию с access list'ами в сетях - почему не сделать на уровне аксесс листов [мб сложнее управлять]

не создавать 10000 паролей вместо маппинга client_id и ролей
куча интеграций

МБ все-таки пивот в S2I

актуальность - у тебя есть куча сервисов которые ходят в базу, кафку. Сервис без базы (состояния) - говно.

--------------------
Зачем нужна авторизация (src: https://habr.com/ru/companies/avito/articles/796851/):
- Контролировать доступ к ручкам. Часть сервисов или отдельные ручки могут содержать чувствительную информацию: данные пользователей или финансовые показатели.
- Логировать изменения. Нужно знать, кто и когда вносил изменения и пользовался ручками, — это основа любой системы безопасности. 
- Не сломать связи X сервисов. Нарушение любой из связей могло привести к деградации продакшена.
- Не менять сервисы. Сервисов много, поэтому заставлять сотни разработчиков вносить изменения в свои сервисы — неправильно.
- Не повлиять на скорость работы. Для некоторых сервисов лишние 10мс — уже критично. 
- Сделать платформенное решение. Некоторые команды уже стали пилить свою локальную авторизацию: например, через JWT-токены. Нам нужно было централизованное и удобное решение, подходящее всем. 

--------------------
Вызовы:
- засунуть куда-то в требования high-load (опасно, нужно продумать)
- Keycloak или написать урезанный Talos?
- PaaS - разработчикам не нужно будет каждый раз самостоятельно с нуля настраивать авторизацию
	(непротиворечит ли он Sidecar? 16 страница)
- Discovery service
- Если поднимать именно микросервисы, возможно придется каждый поднимать в своей виртуальной машине
	- или можно задать явно адреса куда стучаться? возможно, не поднимать кубер и прописать порты докер-машин каждого сервиса 
- поддержка кроме i2i также и U2I


-----------
misc

i2i доступы (кликхаус в кафку/БД и т.п.)

ИБ, zero trust, 
Single sign-on, вопрос безопасности в аутентификации инфраструктуры компании.
Идентификация, аутентификация (проверка подлинности), авторизация (предоставление прав на выполнение действий)

Актуальность:
1) возможно, готовых решений нет
2) создать доп. надстройку над существующей использующейся в компании своей системы s2s/s2i доступов

[] Транзакции 

единая точка доверия - сервис, отвечающий за хранение прав и аутентификацию и авторазицию действий

Юзкейсы:
- получение, двусторонний отзыв прав между инфрастуктурой
- создание/удаление клиента
- получение-выпуск (JWT access и refresh токена с ролями) для авторизации действий i2i и u2i (уже есть?)
- [] секреты (личный пароль сервиса/инфры) и их ротация (крайне маловероятно)
 
 
https://habr.com/ru/companies/huawei/articles/527098/



сайдкар который подписывает запросы и сайдкар, который проверяет подпись
	// что такое сайдкар? рядом с подом sidecar контейнер? - в поде
сайдкар = мидлварь s2s
у постгри свой бинарный протокол вместо grpc; pgx реализует этой протокол?
etcd - база key-value, работает на grpc протоколе


Акт о внедрении в компанию

в диплом про то, что Keycloak неподходит большим компаниям, придется также уточнять, что решение для высоконагруженных систем



---------------
Существующие подходы:
- HashiCorp Vault + Consul
- Red Hat Single Sign-On (Keycloak) + Istio
- AWS IAM + Amazon MSK (Kafka) + RDS Proxy
- OPA (Open Policy Agent) + Styra DAS: Централизованные политики доступа (например, "Микросервис X может читать топик Y в Kafka").
- Apache Ranger (для Hadoop/Kafka/PostgreSQL)
Сравнение решений
Решение	Поддерживаемые сервисы	Протоколы	Сложность
HashiCorp Vault	PostgreSQL, Kafka, Redis	Динамические секреты	Средняя
Keycloak + Istio	Любые (через JWT)	OAuth2/OIDC	Высокая
AWS IAM	AWS-сервисы (MSK, RDS)	IAM-роли	Низкая (только AWS)
OPA	Любые	Rego-политики	Средняя
SPIFFE/SPIRE	Любые (через SVID)	SPIFFE-токены	Высокая

- Keycloak, Okta, Auth0, Amazon Cognito или Azure AD. (iDP)

---------------
Микросервисы можно условно поделить на бизнес и инфраструктурные


----------------
Существующие решения:
- авито - https://habr.com/ru/companies/avito/articles/674296/

--------------
Подходы к аутентификации:
- статические логин/пароль (хранить, например, в env)
- IAM
	Внедрение IAM (Identity and Access Management) и OAuth 2.0 в схему авторизации для доступа к инфраструктурным сервисам (Kafka, PostgreSQL, Redis и др.) меняет подход к управлению доступом, добавляя централизацию и стандартизацию.
	- недостатки: 
	Каждый запрос к PostgreSQL/Kafka может требовать OAuth Introspection (дополнительный RPC).
	Решение: кеширование токенов, но это снижает безопасность.
		- совместимость:
			Не все БД и брокеры поддерживают OAuth2 (например, ClickHouse требует кастомных решений).
			Для Kafka нужно SASL/OAUTHBEARER, но не все клиентские библиотеки стабильно работают.
		- истекший токен
	+ плюсы
	+ централизованный аудит (("Кто имеет доступ к PostgreSQL?").)
	+ Централизованное управление доступом (Все права хранятся в одном месте (Keycloak/Auth0), а не размазаны по БД, Kafka и Redis.)
	+ Стандартизированный протокол 
	 
Подход/плюсы/минусы
IAM + OAuth 2.0	Централизация, стандартизация	Сложность, требует IdP
Vault + Dynamic Secrets	Безопасность (временные секреты)	Дополнительная инфраструктура
Service Mesh (mTLS)	Автоматическая аутентификация	Только для сервисов в mesh

Подробнее про минусы mTLS
2.1. Можно ли сделать роли (read_only, write_only, read_write)?
Нет, в чистом mTLS – только бинарный доступ (да/нет).
Можно ли выписать пользовательский токен для PostgreSQL через mTLS?
Нет, если только mTLS.

Встроенные RBAC	Простота (Postgres/Kafka ACL)	Разрозненное управление
-----
Kafka:
- SASL/SCRAM (login, pass)
- mTLS (взаимный TLS)
- OAuth2



------
- Общая схема

  +-------------------+       +-------------------+       +-----------------------+
  | Клиент            | ----> | Sidecar           | ----> | Инфраструктурный      |
  | (Business Service)|       | (Envoy + Custom   |       | Сервис                |
  | [to delete?]      | <---- | Auth Logic)       | <---- | (Postgres/Redis/...)  |
  +-------------------+       +-------------------+       +-----------------------+
                                ^       ^       ^
                                |       |       |
                        +-------+-------+-------+
                        |               |       |
                +----------------+  +--------+  +---------------+
                | Keycloak (IdP) |  | Redis  |  | JWKS Endpoint |
                +----------------+  +--------+  +---------------+

Компоненты:

Клиент: Бизнес-микросервис или внешний API.

Sidecar:

Envoy Proxy (маршрутизация, TLS).

Custom Auth Service (кеш токенов, проверка прав).

Инфраструктурные сервисы: PostgreSQL, Redis, Kafka и др.

Внешние зависимости:

Keycloak: Выпуск JWT-токенов.

Redis: Кеш access-токенов.

JWKS Endpoint: Публичные ключи для проверки JWT.


- Итоговая схема развертывания                

  +-------------------+       +-------------------+       +-------------------+
  | Клиент            | ----> | Sidecar           | ----> | Postgres          |
  |                   |       | (Go + Envoy)      |       |                   |
  +-------------------+       +---------+---------+       +-------------------+
                                        |
                                        v
                                +----------------+       +-------------------+
                                | Redis (кеш)    | <---- | Keycloak (IdP)    |
                                +----------------+       +-------------------+
                                                           ^
                                                           |
                                                     +-----+-----+
                                                     | JWKS     |
                                                     | Endpoint |
                                                     +----------+
Sidecar — единая точка входа для авторизации.

Кеширование токенов и JWKS снижает нагрузку на IdP.

HTTP/1.1 + JSON — баланс простоты и производительности.
