админская панелька в качестве UI для пользователя
- TTL токена, другие настройки (посмотреть конфиги талоса и скрэтча)
- выдача/отзыв прав
- рефреш токенов, чтобы сразу отследить изменения в правах
- просмотр аудита прав
- включение/отключение подписи/проверки запросов на конкретном сервисе
- централизованное включение/выключение авторизации toggle (подумать про безопасность)

- в идеале легко создать новый инфраструктурный микросервис, в котором из коробки будет работать авторизация (PaaS)
	то есть сделать подобие SDK

+ метрики и графана
	- в идеале все обложить метриками (если использовать Vault, то сколько к нему запросов и т.д.) и в графане показать 	большой дашборд со всеми интеграциями, по идее это красиво 		будет выглядеть
	- тогда можно будет отобразить исследовательскую часть по метрикам в графане
	
	
Сценарии, когда Postgres может запрашивать Redis:
1. Кеширование результата запроса: Postgres выполняет тяжелый SELECT → сохраняет результат в Redis.
2. Сброс кеша при изменении данных: При UPDATE в Postgres → удаление ключа в Redis.



Внешние зависимости:\
- KeyCloak?
- Kubernetes
- Envoy/Istio - service mesh + sidecar
- Vault для секретов (если сложно поднимать, подумать про альтернативу)
- Etcd (https://etcd.io/) конфиг - централизованное включение/отключение авторизации при ЧС (в админке), также юзкейс для i2i
- i2i use-cases: kafka, postgres, clickhouse, etcd, prometheus (metrics ??) ...



Ильяс (про services mesh, discovery, resolver, ...: https://habr.com/ru/companies/ozontech/articles/779266/):
[me:] посмотреть что есть вообще в этом grpc-go, мб что-то взять чтобы не писать свои велосипеды где это не нужно
- например, Envoy делает запросы в приложение Istio, которое в свою очередь всю информацию про сервисы выкачивает из Kubernetes API
- [gRPC] хорош тем, что он практически не требует дополнительных ресурсов, в отличие от сайдкаров (так как сайдкар — это отдельное приложение, которое занимает процессорное время)
	но в отличие от сайдкара, для обновления версии фреймворка требуется пересобирать всё приложение, что может быть сложнее и дольше, чем замена бинаря в сайдкаре.
- В gRPC уже есть ряд реализованных Resolver’ов и Balancer’ов. Некоторое время назад добавили поддержку протокола xDS, который позволяет получать информацию об адресах бэкенда от Istio и других xDS-провайдеров. Также есть дефолтный DNS Resolver, который ходит в DNS и по RoundRobin распределяет запросы по полученным адресам (в отличие от DNS Resolver на уровне net.Transport, который делает Dial на рандомный адрес и отправляет все запросы туда). Называются эти Resolver’ы соответственно xds и dns
- Как альтернативу dns Resolver в k8s можно использовать kuberesolver[https://github.com/sercand/kuberesolver] как легковесное решение без дополнительных sidecar-ов при использование Istio с xDS
	Но если у вас разрастется кластер, то каждый под на таком решении будет создавать трафик на Kubernetes API, что может привести к излишней нагрузки на нем
- (как xDS на gRPC настроить?) Есть официальная документация тут [https://github.com/grpc/grpc-go/blob/master/examples/features/xds/README.md] от самого gRPC-go
	Работает это по следующему принципу: при настройке Istio к каждому поду в кластере добавляется init контейнер, который формирует и сохраняет под собой файлик xds_bootstrap. В нем содержится информация о том, где находится Istio и некоторые доп поля для подключения. Далее для gRPC необходимо прописать путь до этого bootstrap файла и при создании подключения добавить схему Resolver: xds:///. Ориентируясь на полученную информацию, gRPC сделает коннект к Istio и скачает нужную информацию. Плюс он получит Service Config, в котором можно настроить некоторые механизмы балансировщиков. Об этом можно подробнее почитать в документации Istio
	
	
Vault (https://habr.com/ru/companies/ozontech/articles/845290/):
- Немного о Vault. Это инструмент/сервис для хранения секретов, например доступов к базам данных, токенов и других данных, которые не должны попасть в чужие руки. В Vault имеется огромный набор опций для разграничения прав доступа. Также он предоставляет HTTP-интерфейс для взаимодействия, что позволяет использовать его API даже в bash-скриптах. Все данные зашифрованы в оперативной памяти, и просто так получить их нельзя. Благодаря доступным интерфейсам для взаимодействия есть возможность интегрировать Vault с разными системами, а также множество способов доставить секреты до вашего сервиса: configs, переменные окружения и т. д.
Под стартует в K8s-кластере.
Он получает K8s service account token.
С токеном под идёт в Vault.
Vault проверяет токен — и, если всё хорошо, меняет его на токен от Vault. 
С новым токеном сервис получает доступ к секретам. 



