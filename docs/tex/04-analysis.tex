\chapter{Аналитический раздел}

\section{Микросервисная архитектура}

Микросервисы – это архитектурный и организационный подход к разработке программного обеспечения, при котором программное обеспечение состоит из небольших не зависимых сервисов, взаимодействующих через четко определенные интерфейсы API, обычно основанные на протоколах HTTP или gRPC. Эти сервисы принадлежат небольшим автономным командам.
Архитектуры микросервисов упрощают масштабирование и ускоряют разработку приложений, позволяя  внедрять инновации и ускоряя вывод новых функций на рынок.


В монолитных архитектурах все процессы тесно связаны и работают как единая служба. Это означает, что если один процесс приложения испытывает всплеск спроса, необходимо масштабировать всю архитектуру. Добавление или улучшение функций монолитного приложения усложняется по мере роста базы кода. Эта сложность ограничивает экспериментирование и затрудняет реализацию новых идей. Монолитные архитектуры повышают риск доступности приложений, поскольку множество зависимых и тесно связанных процессов увеличивают влияние сбоя одного процесса.

В архитектуре микросервисов приложение строится как независимые компоненты, которые запускают каждый процесс приложения как службу. Эти сервисы взаимодействуют через четко определенный интерфейс с использованием облегченных API. Службы созданы для бизнес-возможностей, и каждая служба выполняет одну функцию. Поскольку они запускаются независимо, каждую службу можно обновлять, развертывать и масштабировать в соответствии со спросом на определенные функции приложения.~\cite{march}

На рисунке изображено отличие в монолитном и микросервисных подходах~\ref{img:m_arch}.

\includeimage
    {m_arch}
    {f}
    {H}
    {0.7\textwidth}
    {Монолитная и микросервисная архитектура}

%\begin{figure}[hbt!]
%	\center{\includegraphics[width=0.7\textwidth]{img/m_arch}}
%	\caption{Монолитная и микросервисная архитектура}
%	\label{img:m_arch}
%\end{figure}
%\FloatBarrier

%Кравченко Даниил Андреевич МИКРОСЕРВИСНАЯ АРХИТЕКТУРА // Интерактивная наука. 2022. №4 (69). URL: https://cyberleninka.ru/article/n/mikroservisnaya-arhitektura (дата обращения: 10.02.2025).


Безопасность в микросервисных системах представляет собой важный аспект, обусловленный характером архитектуры, которая состоит из множества взаимодействующих компонентов. Каждый микросервис, функционирующий как автономная единица, взаимодействует с другими сервисами через API, что создает множество потенциальных точек уязвимости. 
Каждая точка входа является возможностью для несанкционированного доступа злоумышленников, стремящихся воспользоваться недостатками в системе. Компрометация одного микросервиса может иметь цепной эффект, влияя на другие компоненты системы.
Кроме того, микросервисы часто обрабатывают конфиденциальную информацию, что обуславливает необходимость реализации шифрования как в состоянии покоя, так и в процессе передачи данных.~\cite{m_security}

%https://pdf.sciencedirectassets.com/280203/1-s2.0-S1877050921X0004X/1-s2.0-S1877050921003719/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEKr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJGMEQCIFt5wyFni%2ByRmdUpPfHQWiAr1rs3ysLulJHXW3Rtg9UKAiBiETgC453mwjhgvcOQQwBsI%2FH0HH6%2FW1CAsspkM4A4Ayq8BQjD%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAUaDDA1OTAwMzU0Njg2NSIMeUuVRRTV5IWZnjaBKpAFfnGkZDRkvBhswtbopUJaRBodyHs7fy6b%2BzCiqsdGWjgyjOUzYAIUn5%2FTZoJ%2Flg1%2BT74kusC26ZJfDatKF1d9CTTEZkrndmTzXbHNpQd%2FHqFUyAzLxRzHxgJ64sBOpcDlaOR%2BMRQGPX61Ku3iBImFgvUtywNVDMgYOqU672MI%2BnPYR7aIes1ma2RdHZou2hS5J%2BCtZqp46Gg7dSA7tCfRcTBof7b%2FGTc3Qc0FmELDyzgJaCDlC722zIxLcgHHAvmGGxwFq2u47DpeqrXCo%2FeaEy8kAmdXAS1xjaiVnbYWPF9BcAdlQQZRJvd8xDzRUB8TkMzgm7%2FC%2F9Ew5Bm1byja5mLFpPPskrLB1fCHutq7eI76TeZShpUOgWmfEZJrPwfBuR2RNteGbzLoJjGk%2BxCTxmrMX9MMOy4uwWaus4MFpkCW5F2bQ4bWIXZjHLrKlm6W%2FAdU2uVvd%2FNsx8WIl4DpMABst1FsxC38XDu%2FObDgk9fM95t9RWwp3F0VN%2B1t2TO8%2FY09btmTlNB7XDpoYtdw7dLXctomF%2FW%2BRuiIhMM1OWxI4tEFhYLY%2FtPeR40vMl4g5v9FL8xSo3G1k%2FnqVqKPe4ypyfY%2BPaU212B8ooiOYaYjxqLjTNz%2FwKkde2gIEIGq7WlbUSn7YjOlg7V7Hbgr80%2F1pazwoEck1G9p4YumouvAc9kXOEI%2FrManeh4FbZrMq3gOL7Tnw%2Bg04i3xXq0OoitW0RQyn5d2JRDT6aYkPi94Osd1mVeQgq50juxh1UEK8lmn69b6s%2FxPJusg3LljEJCcLyDeXtK65AuRZyMIiJcm%2BT8Ga4pWT%2F59PJDFOzDKBHvPuIHxMh%2BY2M7f9l4tg8VfYfEkwfsvy1QFRf0Mae8wvvqovQY6sgEceKqKmCUhdZGpLTBX8tTAHebNdZU5CJ3pn0FeJRiB%2B%2BMJe67hzaKDBinrn%2BWjEmYUkwkyjg2KwGLmD3bA0FobRLJ9P%2BKZmyAnaPSQK%2BBpZKoeMKvENDySg%2BW0VoTeT2%2FedTDjb7%2BHQEc7PryewP43PuvNz40hjj7qL%2FNtYR78JhkveQyzVXcTxI6dASSljd70utKIEPElvMseg0Q3QVRN0qcS2gmr5Sqnk%2BByUJM0cnzF&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20250210T183611Z&X-Amz-SignedHeaders=host&X-Amz-Expires=299&X-Amz-Credential=ASIAQ3PHCVTYZYEK2O3U%2F20250210%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=b75ace841706cb2835dfa366bc50ae3f5ede4e1e10fad97070f23efca64e7908&hash=5bd8f3ebc7d87b868dc629006ecf0d56d35f3cd199c994da1b557b4cf361077b&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1877050921003719&tid=spdf-44f1ae71-a9f0-469c-9e88-64a16f21864f&sid=5b7c759094bed54bcf3b17686206029db3dcgxrqb&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=08135f5204055752560455&rr=90fe340b4de6e84e&cc=ru





\section{Идентификация, аутентификация и авторизация}
Идентификация представляет собой процесс, в ходе которого система определяет пользователя или объект, предоставляя уникальный идентификатор, такой как логин или номер учетной записи. Этот этап является первым шагом в установлении личности, позволяя системе распознать, с кем она взаимодействует, и подготовить соответствующий механизм контроля доступа.

Аутентификация представляет собой процесс проверки подлинности идентифицированного пользователя или объекта. На этом этапе система требует от пользователя подтверждения своей личности, что может осуществляться через различные методы, например ввод пароля. Прохождение аутентификация обеспечивает уверенность в том, что пользователь действительно является тем, за кого себя выдает.

Авторизация заключается в предоставлении пользователю системы прав доступа к определенным ресурсам или операциям на основании его роли, прав или политик безопасности. Этот процесс определяет, какие действия пользователь может выполнять и к каким ресурсам он имеет доступ, что позволяет минимизировать риски, связанные с несанкционированным доступом.

В рамках этих процессов важную роль играет концепция управления идентификацией и доступом (Identity and Access Management, IAM), которая включает в себя стратегии, технологии и практики, направленные на эффективное управление идентификацией пользователей и их правами доступа в организации. IAM обеспечивает централизованное управление учетными записями пользователей, автоматизацию процессов аутентификации и авторизации.~\cite{iam}

В условия микросервисной архитектуры, когда система состоит из множества независимых компонентов, каждый из которых может обрабатывать запросы от пользователей и других сервисов, есть необходимость в надежной аутентификации. В микросервисах аутентификация в основном реализуется через токены, такие как JSON Web Tokens (JWT), которые обеспечивают безопасный способ передачи информации, шифруя содержимое, о роли и правах одного микросервиса по отношению к другому.

Аутентификация также должна быть интегрирована с механизмами управления доступом, что позволяет не только удостовериться в личности пользователя, совершающего запрос, но и определить его права на доступ к определенным ресурсам и операциям.

Аутентификация в микросервисах должна быть масштабируема, справляясь с ростом количества микросервисов в системе, при этом не теряя в уровне безопасности.~\cite{m_auth}

%https://www.researchgate.net/publication/359387651_Authentication_and_Authorization


%https://www.researchgate.net/publication/317132991_Authentic_techniques_of_authentication_in_microservices









\section{Основные понятия Kubernetes}

\textbf{Kubernetes} --- открытый механизм оркестрации контейнеров для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями~\cite{kubernetes}.

Работающий кластер Kubernetes включает в себя агента, запущенного на нодах (kubelet) и компоненты мастера (APIs, scheduler, etc), поверх решения с распределённым хранилищем. Пример схемы представлен на рисунке~\ref{kuber-overview}.

\includeimage
    {kuber-overview}
    {f}
    {H}
    {0.7\textwidth}
    {Схема инфраструктуры Kubernetes}

Узел (node) --- это отдельная физическая или виртуальная машина, на которой развёрнуты и выполняются контейнеры приложений. Каждый узел в кластере содержит сервисы для запуска приложений в контейнерах (например Docker), а также компоненты, предназначенные для централизованного управления узлом.

Под (pod) --- базовая единица для запуска и управления приложениями: один или несколько контейнеров, которым гарантирован запуск на одном узле, обеспечивается разделение ресурсов и межпроцессное взаимодействие и предоставляется уникальный в пределах кластера IP-адрес. Последнее позволяет приложениям, развёрнутым на поде, использовать фиксированные и предопределённые номера портов без риска конфликта. Поды могут напрямую управляться с использованием API Kubernetes или управление ими может быть передано контроллеру~\cite{kubernetes}.

Том (volume) --- общий ресурс хранения для совместного использования из контейнеров, развёрнутых в пределах одного пода.

Все объекты управления (узлы, поды, контейнеры) в Kubernetes помечаются метками (label), селекторы меток (label selector) --- это запросы, которые позволяют получить ссылку на объекты, соответствующие какой-то из меток. Метки и селекторы — это главный механизм Kubernetes, который позволяет выбрать, какой из объектов следует использовать для запрашиваемой операции~\cite{kubernetes}.

Сервисом в Kubernetes называют совокупность логически связанных наборов подов и политик доступа к ним. Например, сервис может соответствовать одному из уровней программного обеспечения, разработанного в соответствии с принципами многоуровневой архитектуры программного обеспечения. Набор подов, соответствующий сервису, получается в результате выполнения селектора соответствующей метки.

Kubernetes обеспечивает функции обнаружения сервисов и маршрутизации по запросу. В частности, система умеет переназначать необходимые для обращения к сервису IP-адрес и доменное имя сервиса различным подам, входящим в его состав. При этом обеспечивается балансировка нагрузки в стиле Round robin DNS между подами, чьи метки соответствуют сервису, а также корректная работа в том случае, если один из узлов кластера вышел из строя и размещённые на нём поды автоматически были перемещены на другие узлы. По умолчанию сервис доступен внутри управляемого Kubernetes кластера --- например, поды бэкенда группируются для обеспечения балансировки нагрузки и в таком виде предоставляются фронтенду. Также кластер может быть настроен и для предоставления доступа к входящим в его состав подам извне как к единому фронтенду~\cite{kubernetes}.

Контроллер (controller) --- это процесс, который управляет состоянием кластера, пытаясь привести его от фактического состояния к желаемому; он делает это, оперируя набором подов, определяемых с помощью селекторов меток и являющихся частью определения контроллера. Выполнение контроллеров обеспечивается компонентом Kubernetes Controller Manager. Один из типов контроллеров, самый известный — это контроллер репликации (Replication Controller), который обеспечивает масштабирование, запуская указанное количество копий пода в кластере. Он также обеспечивает запуск новых экземпляров пода в том случае, если узел, на котором работает управляемый этим контроллером под, выходит из строя. Другие контроллеры, входящие в основную систему Kubernetes, включают в себя «DaemonSet Controller», который обеспечивает запуск пода на каждой машине (или подмножеством машин), и «Job Controller» для запуска подов, которые выполняются до завершения, например, как часть пакетного задания~\cite{kubernetes}.

Операторы (operators) --- специализированный вид программного обеспечения Kubernetes, предназначенный для включения в кластер сервисов, сохраняющих своё состояние между выполнениями (stateful), таких как СУБД, системы мониторинга или кэширования. Назначение операторов — предоставить возможность управления stateful-приложениями в кластере Kubernetes прозрачным способом и скрыть подробности их настроек от основного процесса управления кластером Kubernetes~\cite{kubernetes}.

Токен Service Account (SA) --- объект Kubernetes, предоставляющий идентичность для внутрикластерных процессов (например, подам). Управляется Kubernetes API, связан с RBAC для контроля доступа, токены SA верифицируются API-сервером~\cite{kubernetes}.

Сертификат Certificate Authority (CA) --- корневой центр сертификации, выпускающий TLS-сертификаты для компонентов кластера (apiserver, etcd, kubelet). Приватный ключ CA хранится защищенно (часто на control-plane нодах), сертификаты компонентов подписываются CA, обеспечивая криптографическую идентичность. Предустановка root CA-сертификата в компонентах гарантирует цепочку доверия~\cite{kubernetes}.

Сертификат Kubernetes API JWKs --- публичные ключи в формате JWKS, используемые для верификации JWT-токенов Service Accounts. Ключи генерируются и публикуются API-сервером (/openid/v1/jwks), подлинность JWKS гарантируется TLS (с валидацией по CA кластера). Динамическое обновление ключей контролируется apiserver~\cite{kubernetes}.

Sidecar-контейнер --- это контейнер, который должен быть запущен рядом с основным контейнером внутри пода. Этот паттерн нужен для расширения и улучшения функциональности основного приложения без внесения в него изменений. Sidecar-контейнеры могут использоваться для выполнения вспомогательных функций для main-контейнера: логирования, мониторинга, аутентификации, фоновых процессов или тестирования функциональности приложений~\cite{sidecar}.

Sidecar-контейнеры размещаются в той же внутренней сети, что и main-контейнер. Основное приложение может обращаться к sidecar-контейнеру, используя localhost с указанием порта, на котором работает sidecar-контейнер. Порты main- и sidecar-контейнера должны быть разными~\cite{sidecar}.


\section{Обзор существующих решений}

\subsection{Service Mesh}

Service Mesh --- слой инфраструктуры (data plane + control plane), управляющий сетевым взаимодействием между сервисами в кластере Kubernetes, обеспечивает mTLS, балансировку, наблюдаемость и базовую авторизацию. Пример инфраструктуры приведен на рисунке~\ref{svc_mesh}. Внедряется через sidecar-прокси (Envoy в Istio).
Istio - это открытая платформа сервисной сетки, предоставляющая единый слой управления сетевыми взаимодействиями между микросервисами. Она включает управляющую плоскость (Control Plane) и плоскость данных (Data Plane), которые работают совместно для достижения функциональности сетки~\cite{svc_mesh_cite}.

\includeimage
    {svc_mesh}
    {f}
    {H}
    {0.7\textwidth}
    {Инфраструктура Service Mesh}

Аутентификаця базируется на автоматически генерируемых X.509 сертификатах, привязанных к Kubernetes ServiceAccounts. Control plane (Istiod) выступает в роли корневого CA, выпуская короткоживущие сертификаты для sidecar~\cite{svcmesh_tls}.

Авторизация в Istio реализуется через AuthorizationPolicy, позволяющий задавать правила на основе идентификатора источника и http-атрибутов~\cite{svc_mesh_cite}.

К недостаткам можно отнести:
\begin{enumerate}
	\item авторизация L7 работает исключительно для HTTP/gRPC, что делает её неприменимой для нативных протоколов PostgreSQL, Kafka, Redis и других инфраструктурных сервисов, использующие свои собственные протоколы;
	\item отсутствует централизованное управление политиками для разнородных систем --- настройка доступа к БД и брокерам требует отдельных механизмов;
	\item верификация сложных политик требует обращений к control plane~\cite{svc_mesh_cite}.
\end{enumerate}

\subsection{SPIFFE/SPIRE}

SPIFFE (Secure Production Identity Framework For Everyone) – стандарт для унифицированной идентификации рабочих нагрузок в гетерогенных средах. SPIRE (SPIFFE Runtime Environment) – эталонная реализация, функционирующая как доверенная система выпуска идентификаторов. Решение агностично к платформе оркестрации, поддерживая Kubernetes, виртуальные машины и bare-metal. Архитектура включает сервер SPIRE (управление идентичностью) и агентов (выпуск SVID на нодах).
Сертификаты и токены SVID (X.509/JWT) ограничены временем жизни не более часа, совместимы со стандартом OIDC. Проверка подписи SVID осуществляется без обращения к центральным серверам~\cite{spiffe}. 

Рабочая нагрузка для аутентификации регистрируется в SPIRE-агенте через плагин Workload Attestor (например, на основе Kubernetes ServiceAccount Token). После валидации выпускается SVID. Авторизация при этом не является частью SPIFFE и требует интеграции с внешними PDP (точка политики решения), например Open Policy Agent~\cite{spire}.

В итоге можно сказать, что SPIFFE обеспечивает только аутентификацию, делегируя авторизацию внешним системам, чем становится сложнее управлять. Также отсутствует нативная поддержка авторизации для инфраструктурных сервисов, потребуются кастомные плагины~\cite{spire}. Динамическое управление правами ограничено необходимостью синхронизации между SPIRE и PDP, что может приводить к рассинхронизации реальных прав и фактических.

\subsection{Встроенные RBAC БД}
Категория объединяет протокол-специфичные механизмы управления доступом, которые используются непосредственно в инфраструктурных сервисах. Реализации включают: ролевую модель PostgreSQL (GRANT/REVOKE), ACL Kafka (kafka-acls), ACL Redis, SQL-driven RBAC ClickHouse и пр. Каждый сервис предоставляет свой уникальный API для управления политиками, не интегрированный с Kubernetes~\cite{access_control}.

Проверка прав осуществляется на уровне обработки запроса без внешних вызовов. Также отсутствуют внешние зависимости, так как вся проверка выполняется непосредственно в сервисе. При этом изменение правил часто требует перезапуска сервиса.
Аутентификация осуществляется через статические секреты, например, логин и пароль у PostgreSQL, SASL-ключи у Kafka. При этом имеются статические TLS, обеспечивающие взаимную аутентификацию (mutual TLS)~\cite{access_control}.

Можно сделать вывод, что правами в таких системах управлять тяжело, так как они отличаются от сервиса к сервису и имеют свои собственные протоколы для обмена информации. Автоматическая ротация секретов также не предусмотрена, секреты хранятся статически.

\subsection{OAuth2 Proxy с Open Policy Agent}
Комбинированное решение, где OAuth2 Proxy выполняет аутентификацию запросов через стандартные OIDC-потоки, а Open Policy Agent (OPA) обеспечивает авторизацию на основе политик Rego. Архитектура предполагает развёртывание OAuth2 Proxy в качестве ингресс-шлюза перед защищаемыми сервисами. OPA функционирует как отдельный сервис или sidecar~\cite{access_control}.

OAuth2 Proxy проверяет токены через IdP (Keycloak, Okta), поддерживаются разные flow авторизации, такие как Client Crenedials и Authorization Code. Для авторизации OAuth2 Proxy отправляет атрибуты запроса (JWT, метод, путь) в OPA, где затем оцениваются политики на языке Rego. В листинге~\ref{lst:example.rego} приведен пример проверки прав на основе политик. 
\includelisting
	{example.rego}{Оценка политики на языке Rego}

К преимуществам этого решения можно отнести:
\begin{enumerate}
	\item Rego используется как унифицированный язык политик для всех сервисов;
	\item поддерживает стандарты OIDC, OAuth 2.0, JWT;
	\item политики OPA обновляются через API, что делает удобным управление прав;
\end{enumerate}

Решение обладает следующими недостатками:
\begin{enumerate}
	\item каждый запрос на авторизацию требует синхронного вызова к OPA, добавляя нагрузку;
	\item к разным сервисам потребуется разработка специализированных под конкретный сервис адаптер между HTTP-запросом и кастомизированным протоколом сервиса;
	\item автоматическая ротация секретов не поддерживается, управление ключами OAuth2-клиентов осуществляется вручную.
\end{enumerate} 

\subsection{Сравнение}

Для сравнения рассмотренных решений можно выделить следующие критерии:
\begin{itemize}
	\item централизация --- единая точка управления правами для всех типов инфраструктурных сервисов;
	\item локальная валидация --- проверка подлинности без сетевых вызовов к внешним сервисам;
	\item ротация --- регулярная автоматическая смена ключей/токенов через определенный промежуток;
	\item универсальность --- возможность использовать решение в разных инфраструктурных сервисах, решение не должно быть разработано под какой-то исключительно один или два сервиса.
\end{itemize}

\begin{table}[H]
\caption{Сравнение существующих решений}
\label{tabular:comparison}
\begin{tabular}{|p{3.5cm}|p{3cm}|p{2.5cm}|p{2cm}|p{3cm}|}
\hline
\textbf{Решение} & \textbf{Централи- зация} & \textbf{Локальная валидация} & \textbf{Ротация} & \textbf{Универсаль- ность}
\tabularnewline
\hline
Service Mesh & нет & нет & да & нет 
\tabularnewline
\hline
SPIFFE/SPIRE	 & нет & да & да & да
\tabularnewline
\hline
Встроенные RBAC БД & нет & да & нет & нет 
\tabularnewline
\hline
OAuth2 Proxy с OPA & да & нет & нет & нет
\tabularnewline
\hline

\end{tabular}
\end{table}

Судя по результатам сравнения, ни одно из рассмотренных решений не удовлетворяет сразу всем критериям.

\section{Протоколы аутентификации}
В данном разделе будут рассмотрены протоколы аутентификации, структуры и сущности, которыми они оперируют, и их flow. Flow авторизации --- это последовательность шагов, которые проходят объект авторизации, в данном случае микросервисы, для получения доступа к защищенным ресурсам.
Все протоколы применяются как системах с пользователем и сервером, так и в распределенных системах с микросервисной архитектурой.

\subsection{OAuth 1.0 и OAuth 2.0}
OAuth (Open Authorization) --- это открытый стандарт, разработанный для делегирования доступа к защищенным ресурсам без необходимости передачи учетных данных пользователя. Он стал основой для более совершенной версии — OAuth 2.0, выпущенной в 2012 году, описанный в стандарте RFC-6749~\cite{oauth2_spec}. OAuth 2.0 расширяет возможности своего предшественника, предлагая более гибкую архитектуру и упрощенные механизмы авторизации, один из самых используемых в современных веб-приложениях и API.~\cite{oauth2_artc}

% cite RFC-6749?

Протокол OAuth включает несколько ключевых сущностей:
 \begin{enumerate}
  \item[1)] ресурсный владелец (Resource Owner) --- это пользователь, который предоставляет доступ к своим защищенным ресурсам;
  \item[2)] клиент (Client) --- приложение, которое запрашивает доступ к защищенному ресурсу от имени resource owner и с его разрешения;
  \item[3)] сервер авторизации (Authorization Server) --- сервер, который отвечает за аутентификацию ресурсного владельца и выдачу токенов доступа. Он управляет процессом авторизации и хранит учетные данные пользователей;
  \item[4)] ресурсный сервер (Resource Server) --- это сервер, который хранит защищенные ресурсы и принимает запросы на доступ к ним на основании токенов доступа, выданных авторизационным сервером. Сервис может быть одновременно как клиентом, так и сервером.
\end{enumerate}

OAuth 2.0 основывается на концепции токенов доступа, например JWT, которые используются для авторизации запросов к защищенным ресурсам.
Основными компонентами структуры OAuth являются:
 \begin{enumerate}
  \item[1)] токен доступа (Access Token) --- это строка с зашифрованным содержанием, которая представляет собой разрешение на доступ к защищенным ресурсам. Токены доступа имеют ограниченный срок действия и могут быть отозваны;
  \item[2)] токен обновления (Refresh Token) --- это токен, который используется для получения нового токена доступа после истечения его срока действия. Токены обновления позволяют клиенту продолжать доступ к ресурсам без повторной аутентификации пользователя;
  \item[3)] клиентский идентификатор (Client ID) и секрет клиента (Client Secret) --- эти идентификаторы используются для аутентификации клиента на авторизационном сервере.
\end{enumerate}

OAuth 2.0 поддерживает несколько потоков авторизации (authorization flows), каждый из которых предназначен для определенных сценариев использования.
Из них можно выделить основные:
 \begin{enumerate}
  \item[1)] Authorization code --- этот flow основан на редиректах. Клиент должен уметь взаимодействовать с user-agent (обычно браузером) и обеспечивать клиент-серверное взаимодействие;
  \item[2)] Client Credentials --- этот flow больше остальных подходит для микросервисов. Авторизация выполняется на основе client id и client secret, что по сути из себя представляет логин и пароль, по которым сервер авторизации выдает клиенту access token к запрашиваемому ресурсу. На рисунке~\ref{img:oauth2flow} представлен данный flow;
  \item[3)] Implicit --- по логике похож на Authorization code, но с тем отличием, что после успешной авторизации resource owner вместо получения authorization-code и его обмена на access token, сервер авторизации сразу возвращает access token в query в redirect URI.~\cite{oauth2_spec}
\end{enumerate}

\includeimage
    {oauth2_flow}
    {f}
    {H}
    {0.7\textwidth}
    {OAuth2.0 Client Credentials flow авторизации}

%\begin{figure}[hbt!]
%	\center{\includegraphics[width=0.7\textwidth]{img/oauth2_flow}}
%	\caption{OAuth2.0 Client Credentials flow авторизации}
%	\label{img:oauth2flow}
%\end{figure}
%\FloatBarrier

% https://docs.oracle.com/cd/F25688_01/service_layer/SL%20WebSphere%20installation/Content/Deployment%20Guide%20for%20IBM%20Websphere/Webpshere%20Security/Client%20Credentials%20Flow.htm

% https://habr.com/ru/companies/banki/articles/862516/

\subsection{OpenID Connect}
OpenID Connect (OIDC) представляет собой протокол аутентификации, построенный на основе OAuth 2.0, который позволяет клиентским приложениям проверять личность пользователей на основе аутентификации, выполненной авторизационным сервером. OAuth2.0 и OIDC часто используют вместе.~\cite{oidc}

Данный протокол содержит все те сущности и структуру, описанную в OAuth протоколе.
Основные отличия данных протоколов:
 \begin{enumerate}
  \item[1)] ID Token --- это токен, который содержит в зашифрованном виде информацию о пользователе, а также данные о сессии аутентификации. ID Token является основным элементом OpenID Connect и обычно кодируется в формате JWT (JSON Web Token). В OAuth2.0 токен не содержит информации о клиенте;
  \item[2)] flow oidc позволяют клиентам получать как Access, так и ID Token;
  \item[3)] в поле применения OIDC используется больше как протокол аутентификации, OAuth2.0 в связке с ним используется как протокол авторизации.
\end{enumerate}

\subsection{SAML}
Протокол SAML (Security Assertion Markup Language) представляет собой стандарт, разработанный для обмена аутентификационной и авторизационной информацией между различными доменами безопасности.

Можно выделить основные сущности в данном протоколе:
 \begin{enumerate}
  \item[1)] Актор (Principal) --- это пользователь или субъект, который пытается получить доступ к защищенным ресурсам. Актор инициирует процесс аутентификации;
  \item[2)] Identity Provider (IdP) --- это система, которая отвечает за аутентификацию акторов и выдачу утверждений (assertions). IdP проверяет личность пользователя и создает SAML-утверждения, которые содержат информацию о пользователе;
  \item[3)] Service Provider (SP) --- это система, которая предоставляет доступ к защищенным ресурсам. SP полагается на утверждения, выданные IdP, для принятия решения о том, предоставлять ли доступ пользователю;
  \item[4)] SAML-утверждение (SAML Assertion) --- это XML-документ, который содержит информацию о пользователе и его аутентификации. Утверждения могут содержать данные о том, как и когда пользователь был аутентифицирован, а также атрибуты, которые описывают пользователя.
\end{enumerate}

Также можно выделить основную структуру протокола SAML:
 \begin{enumerate}
  \item[1)] SAML-Запрос (SAML Request) --- сообщение, отправляемое SP в IdP с запросом на аутентификацию пользователя. Запрос может быть представлен в виде HTTP-запроса, содержащего параметры, такие как идентификатор запроса и URL-адрес, на который должно быть отправлено ответное сообщение;
  \item[2)] SAML-Ответ (SAML Response) --- сообщение, отправляемое IdP обратно в SP после успешной аутентификации пользователя. Ответ содержит SAML-утверждение, которое подтверждает аутентификацию и может содержать атрибуты пользователя;
  \item[3)] XML --- все сообщения SAML формализуются в виде XML-документов, что обеспечивает  структурированный формат для обмена данными.
\end{enumerate}

SAML имеет следующий flow авторизации, представленный на рисунке~\ref{img:samlflow}:

\includeimage
    {saml_flow}
    {f}
    {H}
    {0.7\textwidth}
    {SAML flow авторизации}

%\begin{figure}[htb!]
%	\center{\includegraphics[width=0.7\textwidth]{img/saml_flow}}
%	\caption{SAML flow авторизации}
%	\label{img:samlflow}
%\end{figure}
%\FloatBarrier

 \begin{enumerate}
  \item[1)] инициация запроса на аутентификацию --- актор пытается получить доступ к ресурсу на SP, который определяет, что актор не аутентифицирован, и перенаправляет его на IdP с SAML-запросом на аутентификацию. Запрос обычно кодируется в URL и передается через HTTP-редирект;
  \item[2)] аутентификация пользователя --- IdP получает SAML-запрос и инициирует процесс аутентификации. После успешной аутентификации IdP создает SAML-утверждение, которое содержит информацию о пользователе;
  \item[3)] отправка SAML-ответа --- IdP формирует SAML-ответ, который включает в себя SAML-утверждение, и перенаправляет актера обратно к SP. Ответ может быть передан через HTTP POST или HTTP Redirect;
  \item[4)] обработка SAML-ответа --- SP получает SAML-ответ и проверяет его подлинность. Если SAML-утверждение действительно, SP выполняет авторизацию пользователя на основе атрибутов, содержащихся в утверждении (например, имя, адрес электронной почты, роли и права доступа);
  \item[5)] доступ к ресурсу --- после успешной авторизации SP предоставляет доступ к защищенным ресурсам актору.~\cite{saml}
\end{enumerate}


\section{Постановка задачи}
Формализованная постановка задачи в виде IDEF-0 диаграммы нулевого уровня представлена рисунке~\ref{img:a0}:

\includeimage
    {a0}
    {f}
    {H}
    {0.8\textwidth}
    {Формализованная постановка задачи}


\section*{Вывод}
В данном разделе были рассмотрены основные понятия микросервисной архитектуре, инструменте и сущностях Kubernetes,паттерна Sidecar, рассмотрены существующие решения проблемы авторизации запросов сервисов, протоколы аутентификации, применимые к микросервисной архитектуры и которые могут использоваться для аутентификации инфраструктурных сервисов, а также формализована постановка задачи в виде IDEF-0 диаграммы нулевого уровня.

%\begin{figure}[htb!]
%	\center{\includegraphics[width=0.7\textwidth]{img/saml_flow}}
%	\caption{SAML flow авторизации}
%	\label{img:samlflow}
%\end{figure}
%\FloatBarrier
